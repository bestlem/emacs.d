#+TITLE Emacs configuration How emacs reacts
#+PROPERTY:header-args :cache yes :tangle yes :comments link
* File Handling
** Trash
Well I was going to include [[https://github.com/lunaryorn/osx-trash.el][osx trash]] which uses the trash executable or an applescript to do the proper trash. But realised I don't want to trash files - just those I delete by hand so the patching of the emacs delete is not a good idea. By default emacs does not delete by moving to trash. It is customisable so set to to never.
Think of editing dired
   #+begin_src emacs-lisp
   (setq delete-by-moving-to-trash nil)
   #+end_src
** Protect library and other files
[[https://github.com/rolandwalker/hardhat][Hardhat]] provides an extra layer of protection in your work. If you visit a file which looks unsafe to edit, Emacs will make the buffer read-only -- even when the underlying file is writable.
#+begin_src emacs-lisp
(use-package hardhat                    ; Protect user-writable files
  :ensure t
  :init (global-hardhat-mode)
  :config (validate-setq hardhat-mode-lighter "Ⓗ"))
#+end_src
* Emacs internals
*** Sessions
 Save registers et al but not the whole desktop
 #+begin_src emacs-lisp
 (use-package savehist
   :config
   (setq savehist-additional-variables
		 '(kill-ring
		   search-ring
		   regexp-search-ring
		   last-kbd-macro
		   kmacro-ring
		   shell-command-history
		   Info-history-list
		   register-alist))
   (savehist-mode 1))
 #+end_src
*** Registers
I haven't used before but might try with hydra from [[https://sriramkswamy.github.io/dotemacs/#orgheadline245][Hydra heavy init]]
#+begin_src emacs-lisp
(defhydra sk/hydra-registers (:color blue
									 :hint nil)
  "
 _a_: append     _c_: copy-to    _j_: jump       _r_: rectangle-copy   _q_: quit
 _i_: insert     _n_: number-to  _f_: frameset   _w_: window-config
 _+_: increment  _p_: point-to
  "
  ("a" append-to-register)
  ("c" copy-to-register)
  ("i" insert-register)
  ("f" frameset-to-register)
  ("j" jump-to-register)
  ("n" number-to-register)
  ("r" copy-rectangle-to-register)
  ("w" window-configuration-to-register)
  ("+" increment-register)
  ("p" point-to-register)
  ("q" nil :color blue))

(bind-key "M-r" 'sk/hydra-registers/body)


#+end_src
* Minibuffer memory
  I have had crashes with helpful where emacs has to be killed. Looks like a recursive stack error but also see comment re garbage collection So let's try
  Note this causes a gc when minibuffer ends - perhaps not the best time
  #+begin_src emacs-lisp
  (defun my-minibuffer-setup-hook ()
	(setq gc-cons-threshold most-positive-fixnum))

  (defun my-minibuffer-exit-hook ()
	(setq gc-cons-threshold 800000))

  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
  #+end_src
* Help
Let's use [[https://github.com/Wilfred/helpful][Helpful]]
#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ("<f1> F" . helpful-function)
  ("<f1> ." . helpful-at-point))
#+end_src
* Key Chord
#+begin_src emacs-lisp
(use-package key-chord
  :ensure t
  :config (key-chord-mode 1))
#+end_src
* Delete if selected
Also see [[https://www.emacswiki.org/emacs/DeleteSelectionMode][EmacsWiki]] (and my old init) but cua should do this. Possibly because minor modes are toggles
Issue is lispy removes this as lispy is vi based. Actually my understanding was wrong the issue is select with mouse puts things into system clipboard.
So use separate PRIMARY and CLIPBOARD
  #+begin_src emacs-lisp
  (delete-selection-mode 1)
  (setq select-enable-clipboard nil)
  (setq select-enable-primary t)
  #+end_src
* Scratch buffer
  Need to control how it is restarted. Aquamacs saves it
  #+begin_src emacs-lisp
  (setq initial-major-mode 'emacs-lisp-mode)
  (setq initial-scratch-message nil)
   #+end_src
* Double Letters
Let's stop it. from [[https://emacs.stackexchange.com/a/13975/9874][Emacs SE]]
#+begin_src emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
	   (save-excursion
		 (and (if (called-interactively-p)
				  (skip-syntax-backward "w")
				(= -3 (skip-syntax-backward "w")))
			  (let (case-fold-search)
				(looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
			  (capitalize-word 1)))))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type. "
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
	  (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
	(remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))
#+end_src
** TODO Misspelling correction
See http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html but I need to deal with Aquamacs spelling as well
* Navigation
** Expand region
#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region)
  ("<f2>" . er/expand-region)
  ("<S-f2>" . er/contract-region)
  ("<C-f2>" . er/contract-region))
#+end_src
** Begin end line
There are several ways to make begin go to first non whitespace  then to begin lin, some will then make next press go to defun or buffer.
Note home and end are in Aquamacs osx-mode-map makes life more complex.. Perhaps I will have to unset them to allow modes to do their thingsThese include crux, [[https://github.com/alezost/mwim.el][mwin]] and ergoemacs,  [[https://github.com/alphapapa/mosey.el][mosey]] + snippets on web.
Note that lispy also does this but not back a form
*** Mosey
Try mosey as it has the back function - NB can use paredit, unfortunately does not seem to work with shift and as others do try another.
#+begin_src emacs-lisp
(use-package mosey
  :disabled
  :ensure t
  :bind (
         ;; My personal favorites
         ("<home>" . mosey-backward-bounce)
         ("<end>" . mosey-forward-bounce)
         ))
#+end_src
*** mwin
mwin might have mode aware
#+begin_src emacs-lisp
(use-package mwim
  :ensure t
  :bind ("<home>" . 'mwim-beginning)    ; comment for testing
  ("<end>" . 'mwim-end))
#+end_src
* TODO General old stuff
#+begin_src emacs-lisp
(setq find-file-visit-truename t)	; visit a file under its true name

(setq find-file-existing-other-name t)

(defun dos-to-unix ()
  "Replace \r\n with \n"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ( replace-string "\r\n" "\n" )))


(setq kill-whole-line t)

; --- highlight words during query replacement ---
;
(setq query-replace-highlight t)
; --- incremental search highlights the current match ---
;
(setq search-highlight t)

;
; --- vertical motion starting at end of line keeps to ends of lines ---
;
(setq track-eol t)
(setq truncate-lines t)

;; tabs
(setq-default tab-width 4)
(setq-default tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100))

;; from http://ergoemacs.org/emacs/emacs_make_modern.html but some are in aquamacs
;; and https://github.com/anschwa/emacs.d

;; UTF-8 as default encoding
;; UTF-8 please
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)



;;  Sentences do not end with two spaces
(setq sentence-end-double-space nil)

(progn
  ;; General emacs behaviour
  ;;  From https://sriramkswamy.github.io/dotemacs/

  ;; This package helps to discover the major mode bindings. I use it very occasionally and hence not binding it to any modal binding.
  (use-package discover-my-major
	:ensure t
	:bind (("C-h C-m" . discover-my-major)
		   ("C-h M-m" . discover-my-mode)))



  ;; comment-dwim-2 improves on the existing comment-dwim command for easy commenting. Pretty useful.

  (use-package comment-dwim-2
	:ensure t
	:bind ("M-;" . comment-dwim-2))
  )
#+end_src
* Buffer switch
Switch to last buffer on one key. From https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/
#+begin_src emacs-lisp
(defun er-switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(bind-chord "zz" #'er-switch-to-previous-buffer)

#+end_src
* Buffer removal
** KIll buffer
Normally when you are in a buffer you do ^x-^k to kill the current buffer but emacs asks you for the name. [[http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/][Pragmatic Emacs]] suggests this.
By default C-x k runs the command kill-buffer which prompts you for which buffer you want to kill, defaulting to the current active buffer. I don’t know about you, but I rarely want to kill a different buffer than the one I am looking at, so I rebind C-x k to kill-this-buffer which just kills the current buffer without prompting (unless there are unsaved changes).
#+begin_src emacs-lisp
(defun bjm/kill-this-buffer ()
  "Kill the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))

(bind-key "C-x k" 'bjm/kill-this-buffer)
#+end_src
** Deal with subprocesses
If a buffer has a subprocess running (e.g. shell, racket-run then emacs will prompt to ask if you want to kill it. I think you always do. So from https://emacs.stackexchange.com/a/14511/9874
#+begin_src emacs-lisp
(setq kill-buffer-query-functions
      (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+end_src
