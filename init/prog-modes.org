#+TITLE Emacs configuration org Programming and structured data modes
#+PROPERTY:header-args :cache yes :tangle yes  :comments link

* Common to all programming modes
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:A4CB284C-80C6-491E-898B-9B6519E2757B
:END:
I suspect there is a split between those with a REPL and not. But all I am interested in are REPL.

Need keys for build
f5 has always been my main - build and go used to be build all but now do tests
C-f5 now can be build and run app.
f6 lets try for send to repl as better one key than shift keys.
A later thought is to use f5 as leader use key chords and then others for test
** Code Edit Structure
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:800B97C9-1558-4A77-A66F-C526AEBABFFD
:END:
Indentation and tabs
Look at smart-tabs-insinuate but aggressive indent means not needed, although if I did an Algol language again I might find that not so true.
*** Highlight indents
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:83292AA8-EE2B-4044-9E4B-99DDF6A034D1
:END:
 I have wanted a good visual identification of indentation since I had the dos printer program in mid 80s. I *now* have it. https://github.com/DarthFennec/highlight-indent-guides

  #+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_E4106683-C45F-422A-9DBC-6265837B502D
  #+begin_src emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :diminish highlight-indent-guides-mode
  :init
  (setq highlight-indent-guides-method 'fill)
  (setq highlight-indent-guides-responsive 'stack)

  ;; Indent character samples: ┃| ┆ ┊
  (setq highlight-indent-guides-character ?\┃) ; as I use fill not used
  ;; Leave these as switch light dark modes problematical
  ;; (setq highlight-indent-guides-auto-odd-face-perc 50)
  (setq highlight-indent-guides-auto-stack-odd-face-perc 50)
  (setq highlight-indent-guides-auto-stack-even-face-perc 20)

  ;; (setq highlight-indent-guides-auto-even-face-perc 30)
  ;; (setq highlight-indent-guides-auto-character-face-perc 40)

  :hook ((prog-mode yaml-mode nxml-mode json-mode ) . highlight-indent-guides-mode))
 #+end_src
*** Fill column
:PROPERTIES:
:ID:       org_mark_2020-02-24T14-59-33+00-00_mini12.local:573326D1-BD3B-4F5B-A721-E49A096DE72B
:END:
Where to wrap the line iff too long. Set locally in prog-modes and differ in comment

:PROPERTIES:
:ID:       org_mark_2020-01-24T17-28-10+00-00_mini12:2D7FD607-5E36-49DB-8F1A-7C7E1C7CADE6
:END:
This is from [[https://www.emacswiki.org/emacs/AutoFillMode][emacs wiki]]
However only want to fill modes where there are line based comments e.g. Emacs lisp. If there is a block comment then don't fill
#+NAME: org_mark_2020-01-24T17-28-10+00-00_mini12_9B7EA331-7A72-4DCE-9798-9D3B378A8C1B
#+begin_src emacs-lisp
(defun mwb-prog-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (setq-local fill-column 79)
  (setq-local comment-fill-column 79)
  (auto-fill-mode 1))

;; use by setting in the actual program mode
;;(add-hook 'prog-mode-hook 'mwb-prog-auto-fill)
#+end_src

*** Smartparens
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:838D12E0-E4AA-4DD0-8F6E-56CDA89B5F0E
:END:
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_A84231FF-A68D-44B0-9010-3CD91C8B2DA4
#+begin_src emacs-lisp
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config
  (setq sp-show-pair-from-inside nil)
  (require 'smartparens-config)
  (smartparens-global-mode))
#+end_src
**** Hydra
:PROPERTIES:
:ID:       org_mark_2020-03-30T15-04-16+01-00_mini12.local:88DD45E5-8559-4134-BCC2-05B98204D30C
:END:
From https://gist.githubusercontent.com/ptrv/7e27e0e18ae37d3f80aff7b9da749321/raw/0685c9b9b35b75886eb372b03f9fde601094d089/smartparens-hydra.el
#+NAME: org_mark_2020-03-30T15-04-16+01-00_mini12.local_A1FA269E-859C-44DB-866A-C136AFD05F51
#+begin_src emacs-lisp
(defhydra ptrv/smartparens (:hint nil)
    "
Sexps (quit with _q_)
^Nav^            ^Barf/Slurp^                 ^Depth^
^---^------------^----------^-----------------^-----^-----------------
_f_: forward     _→_:          slurp forward   _R_: splice
_b_: backward    _←_:          barf forward    _r_: raise
_u_: backward ↑  _C-<right>_:  slurp backward  _↑_: raise backward
_d_: forward ↓   _C-<left>_:   barf backward   _↓_: raise forward
_p_: backward ↓
_n_: forward ↑
^Kill^           ^Misc^                       ^Wrap^
^----^-----------^----^-----------------------^----^------------------
_w_: copy        _j_: join                    _(_: wrap with ( )
_k_: kill        _s_: split                   _{_: wrap with { }
^^               _t_: transpose               _'_: wrap with ' '
^^               _c_: convolute               _\"_: wrap with \" \"
^^               _i_: indent defun"
    ("q" nil)
    ;; Wrapping
    ("(" (lambda (_) (interactive "P") (sp-wrap-with-pair "(")))
    ("{" (lambda (_) (interactive "P") (sp-wrap-with-pair "{")))
    ("'" (lambda (_) (interactive "P") (sp-wrap-with-pair "'")))
    ("\"" (lambda (_) (interactive "P") (sp-wrap-with-pair "\"")))
    ;; Navigation
    ("f" sp-forward-sexp )
    ("b" sp-backward-sexp)
    ("u" sp-backward-up-sexp)
    ("d" sp-down-sexp)
    ("p" sp-backward-down-sexp)
    ("n" sp-up-sexp)
    ;; Kill/copy
    ("w" sp-copy-sexp)
    ("k" sp-kill-sexp)
    ;; Misc
    ("t" sp-transpose-sexp)
    ("j" sp-join-sexp)
    ("s" sp-split-sexp)
    ("c" sp-convolute-sexp)
    ("i" sp-indent-defun)
    ;; Depth changing
    ("R" sp-splice-sexp)
    ("r" sp-splice-sexp-killing-around)
    ("<up>" sp-splice-sexp-killing-backward)
    ("<down>" sp-splice-sexp-killing-forward)
    ;; Barfing/slurping
    ("<right>" sp-forward-slurp-sexp)
    ("<left>" sp-forward-barf-sexp)
    ("C-<left>" sp-backward-barf-sexp)
    ("C-<right>" sp-backward-slurp-sexp))

(bind-key "H-["  'ptrv/smartparens/body)
#+end_src
*** [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]]
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:25EEAB16-473F-4321-B9CD-085BD4B97CB5
:END:
 Indent as you type. Only for emacs lisp or racket at the moment. But that failed so back to global - If want to exclude then set (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
 https://github.com/Malabarba/aggressive-indent-mode
 #+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_9DFEE1E2-3416-4ACF-9B5F-44C23CA8722F
 #+begin_src emacs-lisp
(use-package aggressive-indent
  :ensure t
  :after smartparens
  :hook
  (prog-mode . aggressive-indent-mode)
  ;;(python-mode . (lambda () (aggressive-indent-mode -1)))
)
 #+end_src
** Refactor
:PROPERTIES:
:ID:       org_mark_2020-10-14T11-05-37+01-00_mini12.local:A69F6693-E4CF-4C02-B645-5D83516AFE64
:END:
From https://github.com/Wilfred/emacs-refactor
#+NAME: org_mark_2020-10-14T11-05-37+01-00_mini12.local_D19502C6-D155-4612-B223-E1B3D318935B
#+begin_src emacs-lisp

#+end_src
** Comint
:PROPERTIES:
:ID:       org_mark_2020-10-11T00-40-32+01-00_mini12.local:94ACA493-0B43-4754-B711-8F75275EE9B1
:END:
From https://github.com/grettke/lolsmacs/blob/master/lolsmacs.el

Here is the scenario for this style of Comint configuration:

You are doing a lot of interactive work via various Comint-supported buffers. You are working in one buffer (the one with focus) while the others are doing their own thing. They are probably doing work and output is scrolling by and that is fine because you are not reading it. In the
buffer you are working in though, you want to go back and read something. So although it its process continues to output information, you want to keep the cursor in the same spot. Then when you are ready to type a command (suppose you know the output has stopped) to do something else, when you type the cursor will go to the end of the buffer. That is why you prevent the focused buffer from auto-scrolling and moving the mark, and leave the other ones alone.

#+NAME: org_mark_2020-10-11T00-40-32+01-00_mini12.local_0963EB06-7A75-414C-BBC9-C032966D9019
#+begin_src emacs-lisp
(setq comint-scroll-to-bottom-on-input 'this)
(setq comint-scroll-to-bottom-on-output 'others)
(setq comint-move-point-for-output 'others)
(setq comint-scroll-show-maximum-output t)
(setq comint-prompt-read-only nil)
#+end_src
** iMenu in all buffers
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:7BFB1B10-9C15-4630-8415-FFFF2BC88161
:END:
	#+begin_src emacs-lisp
	(add-hook 'prog-mode-hook (lambda () (imenu-add-to-menubar "Imenu")))
	#+end_src
** TODO Folding
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:1928599E-6243-4314-835D-B5D932F7E372
:END:
Keeps changing - the issue is with comments before functions I want to collapse the lot. Plus with racket and ml comments are not in firts column so some (outshine) do not spot it.
Current work to get org mode working better. see send to REPL.

Also see this answer for an addition to highlight indent mode https://stackoverflow.com/a/4459159/151019
*** Hide show
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:E10913D4-7B93-4357-B95F-FA5044D80C3C
:END:
Let us set it up
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_E36E2091-3DAD-46AC-8634-EC11B5E795C7
#+begin_src emacs-lisp
(use-package hideshow
  :hook (prog-mode . hs-minor-mode))
#+end_src
Put markers in the fringe which messed up lispy
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_C0B47E60-5C02-4FCD-AE13-ABA380EA4866
#+begin_src emacs-lisp
(use-package hideshowvis
  :disabled
  :mwb-load-path "site-lisp/hideshowvis"
  :hook (prog-mode . hideshowvis-enable)
  :config (hideshowvis-symbols))
#+end_src

Use a hydra so don't need the odd keybindings
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_780EA095-1E1A-4E1C-956D-17C68D30AE73
#+begin_src emacs-lisp
(defhydra hydra-hs (:idle 1.0)
  "
Hide^^            ^Show^            ^Toggle^    ^Navigation^
----------------------------------------------------------------
_h_ hide all      _s_ show all      _t_oggle    _n_ext line
_d_ hide block    _a_ show block              _p_revious line
_l_ hide level

_SPC_ cancel
"
  ("s" hs-show-all)
  ("h" hs-hide-all)
  ("a" hs-show-block)
  ("d" hs-hide-block)
  ("t" hs-toggle-hiding)
  ("l" hs-hide-level)
  ("n" forward-line)
  ("p" (forward-line -1))
  ("SPC" nil))

(bind-key "H-h" 'hydra-hs/body)
#+end_src
*** Outlining
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:8D4F7694-0606-4178-A927-DE9365C03B2E
:END:
Basically want to collapse/fold depending on comments.
[[https://github.com/alphapapa/outshine][Outshine]] seems to be the only one still under developement, but dioes too much and has the problem that it looks for comments in colum 1 as does hideshow.
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_CCD484C1-6BB3-4AFD-8A66-0B2F7722A8B6
#+begin_src emacs-lisp
(use-package outshine
  :ensure t
  :hook (outline-minor-mode . outshine-hook-function)
  :init
  ;; (add-hook 'outline-minor-mode-hook #'outshine-hook-function)
  :bind (:map outline-minor-mode-map
              ("M-p" . outline-previous-visible-heading)
              ("M-p" . outline-next-visible-heading)
              ("<S-tab>" . outshine-cycle-buffer))
  :preface
  (defvar outline-minor-mode-prefix "H-o") ;  to set before loading note other package name
  )
#+end_src
*** Folding
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:5E3357DF-791A-45BB-8DD8-300C3689C284
:END:
Lets try another
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_30083007-CADD-49A5-8AC3-23B14475C3BB
#+begin_src emacs-lisp

#+end_src
** Build systems
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:0BE82E38-EDB5-4196-B76E-FB6F1DBC0791
:END:
*** Gradle
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:D059B203-9EB7-4713-8AB5-3D49422DAFD7
:END:
 As Emacs is bad for java my java setup is now just gradle so that should be a generic build when I rename.
This also takes time to load. Need to sort out config entries and gradele-mode needs a bind as you need the keystrokes but only in some modes.
 #+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_8FC0E8CB-72D8-4306-96E3-F856F8917088
 #+begin_src emacs-lisp

 ;; gradle and other java
 ;; from http://www.coli.uni-saarland.de/~slemaguer/emacs/main.html#orgac34543

 (use-package groovy-mode
   :disabled

   :ensure t
   :mode ("\.groovy$" "\.gradle$")
   :interpreter ("gradle" "groovy")
   :init
   (autoload 'run-groovy "inf-groovy" "Run an inferior Groovy process")
   (autoload 'inf-groovy-keys "inf-groovy" "Set local key defs for inf-groovy in groovy-mode")
   ;; Subpackages
   (use-package groovy-imports :ensure t)
   ;; Some keys for
   (add-hook 'groovy-mode-hook
			 '(lambda ()
				(inf-groovy-keys))))


 ;; ;; This does work with Aquamacs
 ;; (add-to-list 'auto-mode-alist (cons "\\.gradle\\'" 'groovy-mode))
 ;; (add-to-list 'auto-mode-alist (cons "\\.groovy\\'" 'groovy-mode))
 ;; ;; This _might_ not work with Aquamacs (not sure what value it offers)
 ;; ;(add-to-list 'interpreter-mode-alist '("groovy" . groovy-mode))
 ;; ;(add-to-list 'interpreter-mode-alist '("gradle" . groovy-mode))

 ;; ;;; make Groovy mode electric by default.
 ;; (add-hook 'groovy-mode-hook
 ;;           '(lambda ()
 ;;              (require 'groovy-electric)
 ;;              (groovy-electric-mode)))
 ;; (require 'gradle)

 (use-package gradle-mode
   :ensure t
   :diminish
   :disabled
   :config
   (setq gradle-gradlew-executable "./gradlew"
		 gradle-use-gradlew t)
   (gradle-mode))
 #+end_src
*** make
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:C53BB68B-57E2-4F16-9BE7-B629633B3C4B
:END:
	#+begin_src emacs-lisp
	(use-package make-mode
	  :ensure nil
	  :mode
	  ("Imakefile\\'" . makefile-imake-mode)
	  ("Makeppfile\\(?:\\.mk\\)?\\'" . makefile-makepp-mode)
	  ("\\.makepp\\'" . makefile-makepp-mode)
	  ("\\.mk\\'" . makefile-bsdmake-mode)
	  ("\\.make\\'" . makefile-bsdmake-mode)
	  ("GNUmakefile\\'" . makefile-gmake-mode)
	  ("[Mm]akefile\\'" . makefile-bsdmake-mode)
	  ("\\.am\\'" . makefile-automake-mode))
	#+end_src
	#+begin_src emacs-lisp
	(use-package cmake-mode
	  :ensure t
	  :mode
	  ("\\.cmake\\'" . cmake-mode)
	  ("CMakeLists\\.txt\\'" . cmake-mode)
	  :config
	  (setq cmake-tab-width 2))
	#+end_src
** REPL
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:558A449F-72D3-4F5C-BCE0-02C011944F6B
:END:
Yes you think of lisp, smalltalk but also Swift python, ML, Haskell. I never got on with it, I always wanted the whole program and seeing the ML course and Racket, it is not a major thing as you have to often start again which helps for repeatability.

I want a key to send current buffer, especial in OrgSrc mode to REPL.
[[https://github.com/kaz-yos/eval-in-repl][Eval in Repl]] seems a base but it in effect uses the keymap as to how to choose what to run. Ideally I would want f5 to do this in orgsrc mode, but a full send in normal mode.
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_A713576B-1958-4B3A-B268-DC65DC07499C
#+BEGIN_SRC emacs-lisp
(use-package eval-in-repl
  :ensure t
  :config
  (setq mwb-repl-region-key "<f6>"))
#+END_SRC
*** emacs - ielm
:PROPERTIES:
:ID:       org_mark_2020-02-10T11-53-11+00-00_mini12:DF45202A-884C-4B11-866F-526417609CF2
:END:
This is simple and works. Extended by me to send whole buffer and not switch on key but mode.
Have working base function
#+NAME: org_mark_2020-02-10T11-53-11+00-00_mini12_F4F528CB-9078-4C05-B2A0-23ADCA372044
#+BEGIN_SRC emacs-lisp
(use-package  eval-in-repl-ielm
  :config
  ;; Evaluate expression in the current buffer.
  (setq eir-ielm-eval-in-current-buffer t)
  :bind (:map emacs-lisp-mode-map ( "<f6>". eir-eval-in-ielm)
              :map Info-mode-map ( "<f6>". eir-eval-in-ielm)
              :map lisp-interaction-mode-map ( "<f6>". eir-eval-in-ielm)))
#+END_SRC
However I can't use that for a send to buffer as the map from mode to function is via the keymap
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_D26ABD27-104F-449D-BF75-31B81F383CC5
#+begin_src emacs-lisp
(setq eir--assoc '())

(defun eir-mwb-send-to-repl ()
  "Send the repl to the buffer looking up the major mode"
  (interactive)
  (funcall (cdr (assoc major-mode eir--assoc))))

(defun eir-mwb-send-to-repl-define (mode function-name)
  "send the last sexpr to the repl using the given function"
  ;; (interactive "P")
  (add-to-list 'eir--assoc (cons mode function-name)))

(eir-mwb-send-to-repl-define 'emacs-lisp-mode 'eir-eval-in-ielm)
(eir-mwb-send-to-repl-define 'inferior-emacs-lisp-mode 'eir-eval-in-ielm)



#+end_src
* Specific groups
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:3CC4E87A-CFCC-442A-8E6C-35D2C41916EC
:END:
Where there is common put them together. This part is really why I have separate files so I can deal with one thing at a time

Lets just load them not explicitly - everything in prog-modes (a better name would be modes or config However leave as this breaks git history)
#+NAME: org_mark_2020-11-05T10-37-03+00-00_mini12.local_8504E6E2-7344-4462-9C3B-F52C34EA1387
#+begin_src emacs-lisp
(dolist (f (directory-files
            (expand-file-name "init/prog-modes" mwb-user-emacs-directory)
            nil
            (rx-to-string '(seq  any ".org" eol)
                          ;; might need to add sort by length here - stops the
                          ;; choice of word splitter - or _ issue
                          )))
  (mwb-init-load (concat "init/prog-modes/" (file-name-sans-extension f))))
#+end_src

** SQL
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:FA08DE52-A532-4D20-AB12-A3B358E3FC56
:END:
Not worth separating out.
Note this is not the internal mode. It is from Emacs wiki as I like the interaction buffer better. Emacs' ones gave too many. Probably was my most used mode at work. As Java was Eclipse.
Now I have no idea if it works
#+NAME: org_mark_2020-11-05T12-42-05+00-00_mini12.local_CBD5D985-056C-4F30-B876-4311EB15D93A
#+begin_src emacs-lisp
(use-package sql-mode
  :mwb-load-path "site-lisp/sql")


;; (autoload 'sql "sql-mode"
;;   "Start the interactive SQL interpreter in a new buffer." t)

;; (autoload 'sql-mode "sql-mode"
;;   "Mode for editing SQL files and running a SQL interpreter." t)

;; (autoload 'sql-buffer "sql-mode"
;;   "Create or move to the sql-mode \"*SQL commands*\" buffer." t)

;; (setq auto-mode-alist (cons '("\\.sql$" . sql-mode) auto-mode-alist))
#+end_src
** C
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:E0F36384-0C3B-4A4A-A24C-2E644372D6C6
:END:
This is where I have really lost history there used to be all sorts of indenation rules.
Look at jojojames init for a complete one - but no lsp/completion.
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_5983974D-B148-47DA-9331-169894A3CCA5
#+begin_src emacs-lisp
   ;; objective C
   (add-to-list 'auto-mode-alist '("\\.h$" . objc-mode) )
   (add-to-list 'auto-mode-alist '("\\.m$" . objc-mode))
   (add-to-list 'auto-mode-alist '("\\.mm$" . objc-mode))
#+end_src
** Perl
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:FD5A12CE-2124-4469-A206-D1C16C2420F1
:END:
Possibly lost as I did have cperl at one time but from comments that might have been before heavy development
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_D396FD6D-BFB0-45D4-9DE2-B8E9CA24D4F5
#+begin_src emacs-lisp
   (setq auto-mode-alist
		 (cons '("\\.pl$" . perl-mode) auto-mode-alist))
   (setq auto-mode-alist
		 (cons '("\\.pm$" . perl-mode) auto-mode-alist))

   ;; set keys
   ;(load-library "perldb")

   (defun my-perl-mode-hook ()
	 "My Perl settings"
	 (define-key perl-mode-map [return] 'newline-and-indent )
	 (define-key perl-mode-map [C-return] 'newline )
	 (setq perl-indent-level 4)
	 (setq perl-continued-statement-offset 4)
	 (setq perl-continued-brace-offset -4)
	 (setq perl-brace-offset 0)
	 (setq perl-brace-imaginary-offset 0)
	 (setq  perl-label-offset -2)
	 (define-key perl-mode-map [f3] 'perldb )
   ;  (setq perldb-command-name "/run/pd/packages/perl/5.003/bin/perl")
   ;  (setq perldb-command-name "/sbcimp/run/pd/perl/prod/bin/perl")
	 )
   (add-hook 'perl-mode-hook 'my-perl-mode-hook)

   ;; perl debug
   ;; (defun my-perldb-mode-hook ()
   ;;   (setq perldb-command-name "/run/pd/packages/perl/5.003/bin/perl")
   ;; )
   ;; (add-hook 'perldb-mode-hook 'my-perldb-mode-hook)
#+end_src
