#+TITLE Emacs configuration -  emacs lisp
#+PROPERTY:header-args :cache yes :tangle yes  :comments link
#+STARTUP: content

Emacs lisp specific extras

Note all loaded immediately as could be called anytime.

* Hydra
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:F65CCA9F-596F-4B8D-A0B2-29C44A4886D3
:END:
#+NAME: org_2020-12-03+00-00_644A7537-C980-48C1-894E-D92826418F53
#+begin_src emacs-lisp
(use-package emacs-lisp-mode
  :mode-hydra
  ("Eval"
   (("b" eval-buffer "buffer")
    ("d" eval-defun "defun [well top level form]")
    ("r" eval-region "region")
    ;; ("f" matcha-elisp-eval-current-form-sp "form")
    )
   "REPL"
   (("I" ielm "ielm")
    ;; ("x" matcha-goto-scratch "*Scratch*")
    )
   "Test"
   (("t" ert "prompt")
    ("T" (ert t) "all")
    ("F" (ert :failed) "failed"))

   "Debug"
   (("m" sk/hydra-macro-step/body "Macrostep...")
    ("e" modi/toggle-edebug "Toggle edebug")
    ("E" hydra-edebug "edebug hydra")
    ("q" cancel-debug-on-entry "Cancel Debug on Entry")
    ("D" debug-on-entry "Debug on Entry"))
   ;; ["Watch"
   ;;  ("w" debug-watch "Watch")
   ;;  ("W" cancel-debug-watch  "Cancel Watch")]
   "Compile"
   (("c" emacs-lisp-byte-compile "Compile")
    ("l" emacs-lisp-byte-compile-and-load "Compile and Load")
    ("r" byte-recompile-directory "Byte Recompile Directory")
    ("x" disassemble "Disassemble"))))
#+end_src

* Formatting
:PROPERTIES:
:ID:       org_mark_2020-03-02T07-49-31+00-00_mini12.local:B2DA6147-D1C4-4D09-9702-371808CB3424
:END:
** Formatter
:PROPERTIES:
:ID:       org_mark_2020-11-24T18-08-50+00-00_mini12.local:94566E0B-CB36-4CFF-84ED-8E1C9460ABB5
:END:
I am not certain this is needed now as other things do this. Aggressive indent for example
However I had a lot of strings so tried.
*** elisp formatter
:PROPERTIES:
:ID:       org_mark_2020-11-24T18-08-50+00-00_mini12.local:254245E4-B413-4094-9DB5-555CC09FAC81
:END:
    After a use not that good
    #+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_371FFD2B-49E8-4C8D-BD20-E974C39BA8E2
    #+begin_src  emacs-lisp :tangle no
(use-package elisp-format
  :disabled
  :defer 10
  :ensure t)
    #+end_src
*** [[https://github.com/tuhdo/semantic-refactor][Semantic Refactor]]
:PROPERTIES:
:ID:       org_mark_2020-11-24T18-08-50+00-00_mini12.local:CB649654-2804-4D51-8437-55D5DC0A68F6
:END:
Just for lisp But seems no better
Plus the lisp formatting is not autoloaded
#+NAME: org_mark_2020-11-24T18-08-50+00-00_mini12.local_BA7E1106-4E0E-4D38-B512-2C59194F3F4D
#+begin_src emacs-lisp :tangle no
(use-package srefactor
  :disabled
  :ensure t
  :init (use-package srefactor-lisp))
#+end_src
** Extra font lock
:PROPERTIES:
:ID:       org_mark_2020-10-14T11-05-37+01-00_mini12.local:88799E8A-FACD-4227-BF70-7FFD40FC2CF1
:END:
#+NAME: org_mark_2020-10-14T11-05-37+01-00_mini12.local_FA432C27-28F7-4E01-B4C3-A28516C3DFB4
#+begin_src emacs-lisp
(use-package lisp-extra-font-lock
  :ensure t
  :hook (emacs-lisp-mode . lisp-extra-font-lock-mode))
#+end_src
** Filling
:PROPERTIES:
:ID:       org_mark_2020-03-02T07-49-31+00-00_mini12.local:E19FC44E-6C80-4DD8-BBFA-99156DD9884D
:END:
We want to wrap comments.
#+NAME: org_mark_2020-03-02T07-49-31+00-00_mini12.local_40B17E22-5242-4E2A-86DA-FBA14F107693
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'mwb-prog-auto-fill-80)
#+end_src
* See macros
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:87193D42-251A-408C-80B7-839BF6CFCE81
:END:
	Dependencies because lispy etc and macrostep use the same keys
	#+begin_src emacs-lisp
    (use-package macrostep
      :ensure t
      :after (emacs-lisp lispy-mnemonic lispy)
      :commands (macrostep-expand
                 macrostep-mode)
      ;;:config (set macrostep-expand-in-separate-buffer t)
      :bind (:map emacs-lisp-mode
                  ("C-c e m" . macrostep-expand)))
	#+end_src
and the hydra is from https://sriramkswamy.github.io/dotemacs/ . Note it expands what is at current point,
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_6CEAF9C9-8E76-4E4D-AB8D-2255FB8A5D42
#+begin_src emacs-lisp
(defhydra sk/hydra-macro-step (:pre (macrostep-expand)
                                    :color pink
                                    :hint nil)
  "
 _e_: expand    _j_: next macro    _C_: collapse all
 _c_: collapse  _k_: prev macro    _q_: quit
"
  ("e" macrostep-expand)
  ("c" macrostep-collapse)
  ("j" macrostep-next-macro)
  ("k" macrostep-prev-macro)
  ("C" macrostep-collapse-all)
  ("q" macrostep-collapse-all :color blue))
#+end_src
* Extra debugging
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:89E63DE0-5A33-4D24-B08B-F0957A1D5311
:END:
** edebug-x
:PROPERTIES:
:ID:       org_mark_2020-10-28T08-11-21+00-00_mini12.local:BBEFF5C5-1FED-4CAE-9EC0-E6FC2491C367
:END:
Seen but not used yet [[https://github.com/ScottyB/edebug-x][edebug-x]]
	#+begin_src emacs-lisp
	(use-package edebug-x :disabled :ensure t)
	#+end_src
** Kaushal Modi edebug hydra
:PROPERTIES:
:ID:       org_mark_2020-10-28T08-11-21+00-00_mini12.local:983EA75B-7D8E-4372-845B-D7CA7ED40D99
:END:
[[https://github.com/kaushalmodi/.emacs.d][His init]]
#+NAME: org_mark_2020-10-28T08-11-21+00-00_mini12.local_CF761341-0D79-4D5B-8D8C-D955F8B346AF
#+begin_src emacs-lisp
;;  mainly from setup-elisp.el


;; Solution to toggle debug on a function whether it is defined inside or
;; outside a `use-package' wrapper
;; http://emacs.stackexchange.com/q/7643/115

;; Edebug a defun or defmacro
(defvar modi/fns-in-edebug nil
  "List of functions for which `edebug' is instrumented.")

(defconst modi/fns-regexp (concat "([[:blank:]]*"
                                  "\\(cl-\\)*"
                                  "\\(defun\\|defmacro\\|defsubst\\)"
                                  "\\**"
                                  "[[:blank:]]+"
                                  "\\(?1:\\(\\w\\|\\s_\\)+\\)\\_>") ; word or symbol char
  "Regexp to find defun or defmacro definition.")

(defun modi/toggle-edebug ()
  (interactive)
  (save-excursion
    (re-search-backward modi/fns-regexp)
    (let ((start (point))
          (fn (match-string 1))
          end
          selection)
      ;; (message "Parsed: %s fns-in-edebug: %s" fn modi/fns-in-edebug)
      (forward-sexp 1)
      (setq end (point))
      (if (member fn modi/fns-in-edebug)
          ;; If the function is already being edebugged, uninstrument it
          (progn
            (setq modi/fns-in-edebug (delete fn modi/fns-in-edebug))
            (eval-buffer)
            (setq-default eval-expression-print-length 12)
            (setq-default eval-expression-print-level  4)
            (message "Edebug disabled: %s" fn))
        ;; If the function is not being edebugged, instrument it
        (save-restriction
          (narrow-to-region start end)
          (add-to-list 'modi/fns-in-edebug fn)
          (setq-default eval-expression-print-length nil)
          (setq-default eval-expression-print-level  nil)
          (edebug-defun)
          (message "Edebug: %s" fn))))))

(defhydra hydra-edebug (:color amaranth
                               :hint  nil)
  "
    EDEBUG MODE
^^_<SPC>_ step             ^^_f_ forward sexp         _b_reakpoint set                previous _r_esult      _w_here                    ^^_d_ebug backtrace
^^_n_ext                   ^^goto _h_ere              _u_nset breakpoint              _e_val expression      bounce _p_oint             _q_ top level (_Q_ nonstop)
_g_o (_G_ nonstop)         ^^_I_nstrument callee      next _B_reakpoint               _E_val list            _v_iew outside             ^^_a_bort recursive edit
_t_race (_T_ fast)         step _i_n/_o_ut            _x_ conditional breakpoint      eval _l_ast sexp       toggle save _W_indows      ^^_S_top
_c_ontinue (_C_ fast)      ^^^^                       _X_ global breakpoint
"
  ("<SPC>" edebug-step-mode)
  ("n"     edebug-next-mode)
  ("g"     edebug-go-mode)
  ("G"     edebug-Go-nonstop-mode)
  ("t"     edebug-trace-mode)
  ("T"     edebug-Trace-fast-mode)
  ("c"     edebug-continue-mode)
  ("C"     edebug-Continue-fast-mode)

  ("f"     edebug-forward-sexp)
  ("h"     edebug-goto-here)
  ("I"     edebug-instrument-callee)
  ("i"     edebug-step-in)
  ("o"     edebug-step-out)

  ;; breakpoints
  ("b"     edebug-set-breakpoint)
  ("u"     edebug-unset-breakpoint)
  ("B"     edebug-next-breakpoint)
  ("x"     edebug-set-conditional-breakpoint)
  ("X"     edebug-set-global-break-condition)

  ;; evaluation
  ("r"     edebug-previous-result)
  ("e"     edebug-eval-expression)
  ("l"     edebug-eval-last-sexp)
  ("E"     edebug-visit-eval-list)

  ;; views
  ("w"     edebug-where)
  ("p"     edebug-bounce-point)
  ("v"     edebug-view-outside) ; maybe obsolete??
  ("P"     edebug-view-outside) ; same as v
  ("W"     edebug-toggle-save-windows)

  ("d"     edebug-backtrace)

  ;; quitting and stopping
  ("q"     top-level :color blue)
  ("Q"     edebug-top-level-nonstop :color blue)
  ("a"     abort-recursive-edit :color blue)
  ("S"     edebug-stop :color blue))
(with-eval-after-load 'edebug
  (bind-key "?" #'hydra-edebug/body edebug-mode-map))

;; Debug on entry
(defvar modi/fns-in-debug nil
  "List of functions for which `debug-on-entry' is instrumented.")

(defun modi/toggle-debug ()
  (interactive)
  (let (fn)
    (save-excursion
      (re-search-backward modi/fns-regexp)
      (setq fn (match-string 1)))
    (if (member fn modi/fns-in-debug)
        ;; If the function is already being debugged, cancel its debug on entry
        (progn
          (setq modi/fns-in-debug (delete fn modi/fns-in-debug))
          (cancel-debug-on-entry (intern fn))
          (message "Debug-on-entry disabled: %s" fn))
      ;; If the function is not being debugged, debug it on entry
      (progn
        (add-to-list 'modi/fns-in-debug fn)
        (debug-on-entry (intern fn))
        (message "Debug-on-entry: %s" fn)))))

#+end_src
* Flycheck
:PROPERTIES:
:ID:       org_2020-12-02+00-00:8AED05A2-E475-45E7-9FE1-2D0C6CBC3F2E
:END:
Partially disabled from https://github.com/IvanMalison/dotfiles/tree/master/dotfiles/emacs.d
Original just stops check for all the package and documentation heading. Need to make it not check for undefined in *xxx* buffers
#+NAME: org_2020-12-02+00-00_7F1FCFB3-782A-4154-AF60-ABEDAAD3F4C5
#+begin_src emacs-lisp
(defun imalison:maybe-remove-flycheck-checkdoc-checker ()
  (when (s-starts-with? "*" (buffer-name))
    (flycheck-disable-checker 'emacs-lisp-checkdoc)))
(add-hook 'flycheck-mode-hook 'imalison:maybe-remove-flycheck-checkdoc-checker)
#+end_src
* Cask
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:A7E444B1-B2D1-477A-A3E2-A7518E90193E
:END:
[[https://github.com/Wilfred/cask-mode][cask-mode]] is a mode for editing [[https://cask.readthedocs.io/en/latest/][cask]] files. Cask is an emacs project management tool. ie contolling dependencies, and running tests like maven etc.

#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_9EC9B695-2F8B-4E9B-B42A-199CF68F6E58
#+begin_src emacs-lisp
(use-package cask-mode :ensure t)
#+end_src

* xah mode
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:FB3F4B30-A5F0-41D1-A9D5-48069D7A5898
:END:
	 This does more formatting and has useful abbreviations but I don't know if will work with lispy
     #+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_93A1C8F8-DA67-4EF7-BA47-905CC3187347
     #+begin_src emacs-lisp
(use-package xah-elisp-mode
  :ensure t
  :disabled
  :hook emacs-lisp-mode)
     #+end_src

* Regular expressions
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:228658D3-54BA-4A19-886D-E0EA8D21B68D
:END:
They are not understanable so these help

** Xr
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:A6466B59-FC11-4679-8AA9-5CED7A0479C6
:END:
And this is the reverse
#+NAME: org_mark_2020-01-24T12-43-54+00-00_mini12_7B9B113B-829F-4036-A58B-4935E812ACA1
#+begin_src emacs-lisp
(use-package xr
  :ensure t)
#+end_src
** TODO Rebuilder
:PROPERTIES:
:ID:       org_mark_2020-10-25T21-37-40+00-00_mini12.local:C249F91B-5718-46E8-996C-33C52996FC3B
:END:
Construct them visually
Needs a hydra
#+NAME: org_mark_2020-10-25T21-37-40+00-00_mini12.local_92CA5AF7-601D-4F23-87CA-0CFD95B24FE6
#+begin_src emacs-lisp
(use-package re-builder
  :defer t
  :commands (re-builder)
  :config
  (setq reb-re-syntax 'rx))
#+end_src
* Keyboard Macros
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:E9B6E3E8-67D0-4CDE-BB96-BE2B4A67C96E
:END:
Well not really lisp but much can be converted to it
** Show as emacs lisp
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:E245B723-C582-4F69-81C5-297385A3B89D
:END:
*** TODO Put these together
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:8AAA8C94-F704-4379-A330-637D1AE0F099
:END:
*** Load the converter to elisp
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:6504C53C-4A9B-40A2-B2DE-8FEA72ED025C
:END:
	#+begin_src emacs-lisp
(use-package elmacro
  :ensure t
  :demand
  :commands (elmacro-mode
             elmacro-show-last-macro
             elmacro-show-last-commands
             elmacro-mode-on))

	#+end_src
*** Hydra for macros
:PROPERTIES:
:ID:       org_mark_2020-01-24T12-43-54+00-00_mini12:AAFEA2AA-603E-4FDA-8D33-A57C9CDC5077
:END:
From [[https://github.com/abo-abo/hydra/wiki/Macro][Hydra wiki]] and [[https://github.com/edil3ra/emacs_save/blob/master/settings.org][another init file]] but not the latter seems to have some odd entries as well so an edit of the two
	  #+begin_src emacs-lisp
(defhydra hydra-keyboard-macros
  (:hint nil
         :color pink
         :pre
         (progn
           (elmacro-mode 1)
           (elmacro-mode-on)
           (when defining-kbd-macro
             (kmacro-end-macro 1))))
  "
              ^Create-Cycle^         ^Basic^          ^Insert^        ^Save^         ^Edit^
            ╭─────────────────────────────────────────────────────────────────────────╯
                    ^_p_^           [_e_] execute    [_i_] insert    [_b_] name      [_'_] previous
                    ^^↑^^           [_d_] delete     [_c_] set       [_K_] key       [_,_] last
             _<f3>_ ←   → _e_       [_o_] edit       [_a_] add       [_x_] register  [_._] losage
                    ^^↓^^           [_r_] region     [_f_] format    [_B_] defun     [_v_] view
                    ^_k_^           [_m_] step                                   [_l_] prev lisp
                   ^^   ^^          [_s_] swap                                   [_L_] commands
            "
  ("<f3>" kmacro-start-macro :color blue)
  ("e" kmacro-end-or-call-macro-repeat)
  ("E" kmacro-end-or-call-macro-repeat :color blue)

  ("p" kmacro-cycle-ring-previous)
  ("k" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("i" kmacro-insert-counter)
  ("c" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" (lambda ()
         (interactive)
         (kmacro-edit-macro)
         (hydra-keyboard-macros/body)) :color blue)
  ("," edit-kbd-macro)
  ("." kmacro-edit-lossage)
  ("u" universal-argument)
  ("v" kmacro-view-macro)
  ("V" kmacro-view-ring-2nd-repeat)
  ("l" elmacro-show-last-macro)
  ("L" elmacro-show-last-commands)
  ("q" nil :color blue))

(bind-key "<f3>" 'hydra-keyboard-macros/body)
	  #+end_src
