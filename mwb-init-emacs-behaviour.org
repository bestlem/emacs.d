#+TITLE Emacs configuration How emacs reacts
#+PROPERTY:header-args :cache yes :tangle yes :comments link
* File Handling
** Trash
Well I was going to include [[https://github.com/lunaryorn/osx-trash.el][osx trash]] which uses the trash executable or an applescript to do the proper trash. But realised I don't want to trash files - just those I delete by hand so the patching of the emacs delete is not a good idea. By default emacs does not delete by moving to trash. It is customisable so set to to never.
Think of editing dired
   #+begin_src emacs-lisp
   (setq delete-by-moving-to-trash nil)
   #+end_src
** Protect library and other files
[[https://github.com/rolandwalker/hardhat][Hardhat]] provides an extra layer of protection in your work. If you visit a file which looks unsafe to edit, Emacs will make the buffer read-only -- even when the underlying file is writable.
#+begin_src emacs-lisp
(use-package hardhat                    ; Protect user-writable files
  :ensure t
  :init (global-hardhat-mode)
  :config (validate-setq hardhat-mode-lighter "â’½"))
#+end_src
* Emacs internals
*** Sessions
 Save registers et al but not the whole desktop
 #+begin_src emacs-lisp
 (use-package savehist
   :config
   (setq savehist-additional-variables
		 '(kill-ring
		   search-ring
		   regexp-search-ring
		   last-kbd-macro
		   kmacro-ring
		   shell-command-history
		   Info-history-list
		   register-alist))
   (savehist-mode 1))
 #+end_src
*** Registers
I haven't used before but might try with hydra from [[https://sriramkswamy.github.io/dotemacs/#orgheadline245][Hydra heavy init]]
#+begin_src emacs-lisp
(defhydra sk/hydra-registers (:color blue
									 :hint nil)
  "
 _a_: append     _c_: copy-to    _j_: jump       _r_: rectangle-copy   _q_: quit
 _i_: insert     _n_: number-to  _f_: frameset   _w_: window-config
 _+_: increment  _p_: point-to
  "
  ("a" append-to-register)
  ("c" copy-to-register)
  ("i" insert-register)
  ("f" frameset-to-register)
  ("j" jump-to-register)
  ("n" number-to-register)
  ("r" copy-rectangle-to-register)
  ("w" window-configuration-to-register)
  ("+" increment-register)
  ("p" point-to-register)
  ("q" nil :color blue))

(bind-key "M-r" 'sk/hydra-registers/body)


#+end_src
* Minibuffer memory
  I have had crashes with helpful where emacs has to be killed. Looks like a recursive stack error but also see comment re garbage collection So let's try
  Note this causes a gc when minibuffer ends - perhaps not the best time
  #+begin_src emacs-lisp
  (defun my-minibuffer-setup-hook ()
	(setq gc-cons-threshold most-positive-fixnum))

  (defun my-minibuffer-exit-hook ()
	(setq gc-cons-threshold 800000))

  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
  #+end_src
* Help
Let's use [[https://github.com/Wilfred/helpful][Helpful]]
#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  ("<f1> F" . helpful-function)
  ("<f1> ." . helpful-at-point))
#+end_src
* Key Chord
#+begin_src emacs-lisp
(use-package key-chord
  :ensure t
  :config (key-chord-mode 1))
#+end_src
* Delete if selected
Also see [[https://www.emacswiki.org/emacs/DeleteSelectionMode][EmacsWiki]] (and my old init) but cua should do this. Possibly because minor modes are toggles
Issue is lispy removes this as lispy is vi based.
  #+begin_src emacs-lisp
  (delete-selection-mode 1)
  #+end_src
* Scratch buffer
  Need to control how it is restarted. Aquamacs saves it
  #+begin_src emacs-lisp
  (setq initial-major-mode 'emacs-lisp-mode)
  (setq initial-scratch-message nil)
   #+end_src
* Double Letters
Let's stop it. from [[https://emacs.stackexchange.com/a/13975/9874][Emacs SE]]
#+begin_src emacs-lisp
(defun dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
	   (save-excursion
		 (and (if (called-interactively-p)
				  (skip-syntax-backward "w")
				(= -3 (skip-syntax-backward "w")))
			  (let (case-fold-search)
				(looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
			  (capitalize-word 1)))))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if dubcaps-mode
	  (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
	(remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))
#+end_src
** TODO Misspelling correction
See http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html but I need to deal with Aquamacs spelling as well
* Navigation
** Expand region
#+begin_src emacs-lisp
;; Better selection
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region)
  ("<f2>" . er/expand-region)
  ("C-<f2>". er/contract-region)
  )

#+end_src
* TODO General old stuff
#+begin_src emacs-lisp
(setq find-file-visit-truename t)	; visit a file under its true name

(setq find-file-existing-other-name t)

(defun dos-to-unix ()
  "Replace \r\n with \n"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ( replace-string "\r\n" "\n" )))


(setq kill-whole-line t)

; --- highlight words during query replacement ---
;
(setq query-replace-highlight t)
; --- incremental search highlights the current match ---
;
(setq search-highlight t)

;
; --- vertical motion starting at end of line keeps to ends of lines ---
;
(setq track-eol t)
(setq truncate-lines t)

;; tabs
(setq-default tab-width 4)
(setq-default tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100))

;; from http://ergoemacs.org/emacs/emacs_make_modern.html but some are in aquamacs
;; and https://github.com/anschwa/emacs.d

;; UTF-8 as default encoding
;; UTF-8 please
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)



;;  Sentences do not end with two spaces
(setq sentence-end-double-space nil)

(progn
  ;; General emacs behaviour
  ;;  From https://sriramkswamy.github.io/dotemacs/

  ;; This package helps to discover the major mode bindings. I use it very occasionally and hence not binding it to any modal binding.
  (use-package discover-my-major
	:ensure t
	:bind (("C-h C-m" . discover-my-major)
		   ("C-h M-m" . discover-my-mode)))



  ;; comment-dwim-2 improves on the existing comment-dwim command for easy commenting. Pretty useful.

  (use-package comment-dwim-2
	:ensure t
	:bind ("M-;" . comment-dwim-2))
  )
;;  Hide show etc


;;  Completer
;; From https://pages.sachachua.com/.emacs.d/Sacha.html#org04e47b9
#+end_src
* Completion
** Text
This is completion for text in buffer
 I need something and company seems to be the current one
 #+begin_src emacs-lisp
 (use-package company
   :ensure t
   :diminish
   :hook (after-init . global-company-mode))
#+end_src
** Emacs
This is completion for emacs commands. Choice is ido, ivy helm.
I'll try ivy.
Note headers have tangle command in to suppress one or other
*** Ido
:PROPERTIES:
  :header-args:    :tangle no
  :END:

**** Find M-x commands
  This is [[https://www.emacswiki.org/emacs/Smex][smex]] buy ivy replaces it.
  #+begin_quote
  Smex is a M-x enhancement for Emacs. Built on top of IDO, it provides a convenient interface to your recently and most frequently used commands. And to all the other commands, too.
  #+end_quote
  #+begin_src emacs-lisp
	(use-package smex
	  :ensure t
	  :config
	  (smex-initialize))
  #+end_src

*** Ivy
Start with a small setup

**** Ivy
	 This is the completion tools
	 Take some for John Wiegley
	 Note takes time to load
	 #+begin_src emacs-lisp
     (use-package ivy
       :ensure t
       :defer 2
       :diminish
       :bind (("C-x b" . ivy-switch-buffer)
              ("H-b" . ivy-switch-buffer)
              ("C-x B" . ivy-switch-buffer-other-window)
              ("M-H"   . ivy-resume))

       :bind (:map ivy-minibuffer-map
                   ("<tab>" . ivy-alt-done)
                   ("SPC"   . ivy-alt-done-or-space)
                   ("C-d"   . ivy-done-or-delete-char)
                   ("C-i"   . ivy-partial-or-done)
                   ("C-r"   . ivy-previous-line-or-history)
                   ("M-r"   . ivy-reverse-i-search)
                   ("<C-return>" . ivy-immediate-done)
                   ( "<ESC>" . minibuffer-keyboard-quit))

       :bind (:map ivy-switch-buffer-map
                   ("C-k" . ivy-switch-buffer-kill))
       :custom
       (ivy-dynamic-exhibit-delay-ms 200)
       (ivy-height 10)
       (ivy-initial-inputs-alist nil t)
       (ivy-magic-tilde nil)
       (ivy-re-builders-alist '((t . ivy--regex-ignore-order)))
       (ivy-use-virtual-buffers t)
       (ivy-wrap t)
       :preface
       (defun ivy-done-or-delete-char ()
         (interactive)
         (call-interactively
          (if (eolp)
              #'ivy-immediate-done
            #'ivy-delete-char)))

       (defun ivy-alt-done-or-space ()
         (interactive)
         (call-interactively
          (if (= ivy--length 1)
              #'ivy-alt-done
            #'self-insert-command)))

       (defun ivy-switch-buffer-kill ()
         (interactive)
         (debug)
         (let ((bn (ivy-state-current ivy-last)))
           (when (get-buffer bn)
             (kill-buffer bn))
           (unless (buffer-live-p (ivy-state-buffer ivy-last))
             (setf (ivy-state-buffer ivy-last)
                   (with-ivy-window (current-buffer))))
           (setq ivy--all-candidates (delete bn ivy--all-candidates))
           (ivy--exhibit)))

       ;; This is the value of `magit-completing-read-function', so that we see
       ;; Magit's own sorting choices.
       (defun my-ivy-completing-read (&rest args)
         (let ((ivy-sort-functions-alist '((t . nil))))
           (apply 'ivy-completing-read args)))
       :config
       (ivy-mode 1)
       (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur)

       ;; Show #/total when scrolling buffers
       (setq ivy-count-format "%d/%d ")
       )
#+end_src

**** Ivy hydra
#+begin_src emacs-lisp :
	 (use-package ivy-hydra
	   :ensure t
	   :after (ivy hydra))
#+end_src

**** Ivy rich
More friendly interface for ivy
#+begin_src emacs-lisp :
(use-package ivy-rich
  :after ivy counsel
  :demand t
  :ensure t
  :config
  (ivy-rich-mode 1)
  (setq ivy-virtual-abbreviate 'full
		ivy-rich-switch-buffer-align-virtual-buffer t
		ivy-rich-path-style 'abbrev))
#+end_src

**** Swiper
Replace isearch
#+begin_src emacs-lisp :

(use-package swiper
  :after ivy
  :ensure t
  :bind (("C-s" . swiper)
		 ("C-r" . swiper))
  )
#+end_src

***** Recentre
	   From [[http://pragmaticemacs.com/emacs/dont-search-swipe/][Pragmatic emacs]] advise swiper to recenter on exit (ivy-display-style defaults to fancy)
	   #+begin_src emacs-lisp
	   (defun bjm-swiper-recenter (&rest args)
		 "recenter display after swiper"
		 (recenter))
	   (advice-add 'swiper :after #'bjm-swiper-recenter)
	   #+end_src
***** TODO Aquamacs
Need to integrate with command FG etc (note thet are separate to C-s

**** Counsel
Improve many emacs functions
#+begin_src emacs-lisp :
(use-package counsel
  :ensure t
  :after ivy
  :bind (("M-x" . counsel-M-x)
		 ("C-x C-f" . counsel-find-file)
		 ("C-x C-r" . counsel-recentf)
		 ("<f1> f" . counsel-describe-function)
		 ("<f1> v" . counsel-describe-variable)
		 ("<f1> l" . counsel-find-library)
										; ("<f2> i" . counsel-info-lookup-symbol)
										; ("<f2> u" . counsel-unicode-char)
		 ("M-i" . counsel-imenu)
		 ("C-c g" . counsel-git-grep)
		 ("C-c j" . counsel-git)
										;("C-c k" . counsel-ag)
		 ("C-c r" . counsel-rg)
		 ("C-x l" . counsel-locate)
		 :map minibuffer-local-map
		 ("C-r" . counsel-minibuffer-add))
  :config
  (if (executable-find "rg")
	  ;; use ripgrep instead of grep because it's way faster
	  (setq counsel-grep-base-command
			"rg -i -M 120 --no-heading --line-number --color never '%s' %s"
			counsel-rg-base-command
			"rg -i -M 120 --no-heading --line-number --color never %s .")
	(warn "\nWARNING: Could not find the ripgrep executable. It "
		  "is recommended you install ripgrep.")))
	 #+end_src

* Buffer switch
Switch to last buffer on one key. From https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/
#+begin_src emacs-lisp
(defun er-switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(key-chord-define-global "zz" #'er-switch-to-previous-buffer)

#+end_src
